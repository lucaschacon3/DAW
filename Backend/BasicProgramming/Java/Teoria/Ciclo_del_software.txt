Ciclo de vida del software:
    - Analisis.
    - Diseño.
    - Codificacion.
    - Pruebas.
    - Documentacion.
    - Explotacion.
    - Mantenimiento.

Analisis (que hace mi programa):
    - Requisitos funcionales (que deje iniciar sesion, poder buscar categorias, que calcule el precio del carrito).
    - Requisitos no funcionales (Interfaz intuitiva, compatible en navegadores, seguridad).
    - Requisitos de informacion (ficheros, BBDD).

Diseño (como hago mi programa):
    - GUI (UX/UI) -> Interfaz de usuario (arbol de navegacion -> Figma).
    - BBDD:
        - Ficheros.
        - Relacionales (SQL) -> El apartado diseño es (Modelo E/R - Modelo Relacional - Normalizacion).
        - NoSQL (NotOnlySQL) -> Documentos grandes (BigData), Clave-Valor (en Ram).
    - Paradigma de la programacion:
        - Programacion estructurada (Diagrama de flujo, pseudocodigo).
        - POO objetos (Diagrama de clases UML).
        - POE eventos (ej. click del raton).
        - Patron de diseño (forma de resolver un problema que aparece constantemente).
    - Arquitectura del software
        - Monolítica -> 1 fichero ejecutable
        - Microservicios -> como AWS.

Codificacion:
    - Pasar de diagrama de clases, diagrama de flujo o pseudocodigo a codigo fuente mediante un IDE.
    - Se usan control de versiones (git).

Pruebas (beta):
    - Interfaz de usuario -> Consola, ventana (GUI).
    - Unitarias (Junit) -> Probar parte del codigo por separado.
    - Integracion e2e -> Juntar partes para probarlo junto.

Documentacion (comprensible durante su vida util):
    - Planificacion del proyecto (grupo) -> Scrum, trello, git/github.
    - Requisitos funcionales/ no funcionales/ informacion.
    - Diseño y arquitectura.
    - Manual tecnico -> API (application program interface).
    - Pruebas -> TDD (test driven development).
    - Mantenimiento y actualizaciones.

Explotacion:
    - Compilacion y creacion de ejecutables.
    - Configuracion de BBDD y servidores.
    - Despliegue y puesta en marcha del SW.
    - Uso -> se monitorea mediante KPI (key performance indicators) (ej. cuanto tarda en cargar la web).

    Modelo de traduccion:
    - Compilacion (c/c++):
        - prog.c ----> compila ----> prog.c (cod. objeto) ----> enlaza (link) ----> librerias (cod. objeto) ----> prog.exe (ejecutable).
    
    - Maquina virtual (Java - JVM) -> Multiplataforma ("Write once, run everywhere"):
        - prog.java ----> compila ----> prog.class (BYTECODES) ----> enlaza (link) ----> librerias (BYTECODES) ----> prog.jar (ejecutable).
        - La maquina virtual (JVM) interpreta BYTECODES.
    
    - Transpilado (TypeScript) -> se transpila a JavaScript (ECMA).

Mantenimiento:
    - Por medio de monitorizacion (KPI).
    - Funcionalidades nuevas.
    - Correccion de errores.

Modelos de ciclos de vida del software:
    - Modelo Cascada (wonderfall)-> Proyectos con requisitos bien definidos.
    - Modelo incremental (incremental) -> Proyectos donde se pueden identificar los modulos definidos con requisitos y funcionalidades proritarias.
    - Modelo espiral (spiral) -> Proyectos arriesgados con requisitos no del todo definidos.
    - Metodologias habiles -> Proyecto con entregas continuas y colaborativas, requisitos no del todo definidos.

